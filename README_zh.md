
# Vanilla JS: Qanda 项目

## 1. 开始之前

### 1.1. 背景

基于 Web 的应用程序已成为构建面向广大用户的数字能力的最常见方式。虽然现在有很多现代化工具可以帮助我们快速构建这些应用，但了解基础的 JavaScript 技术和架构仍然很重要。这不仅能帮助我们在需要时更好地理解这些工具，也能让我们理解 JavaScript 的工作原理。即使在使用 ReactJS 这样的高阶框架时，了解它最终编译出来的代码，也能帮助我们成为更全面的 Web 开发者。

在这个项目中，我需要用 Vanilla JS 构建一个 **前端** 网站（不使用 ReactJS 或其他框架）。这个前端将与一个 RESTful API 后端进行交互，后端使用 JavaScript（NodeJS express server）构建，由我提供。

关于如何与该 API 进行交互的理论背景可以参考我本科 Web 开发课程中的 "promises & fetch" 讲座。

我要构建的这个 Web 应用程序必须是一个单页面应用（SPA）。SPA 给用户的体验就像是原生应用，它的特点是只加载初始的 HTML 页面，之后通过 AJAX/fetch 动态更新页面，而无需重新加载整个页面。通过这种方式，SPA 使用 JavaScript 来生成、渲染和更新页面。由于 SPA 不需要用户离开当前页面进行操作，它保留了用户和应用的状态。因此，整个网站只有一个 `index.html` 文件，"页面之间的切换" 会通过动态修改 DOM 来实现。如果该网站不是单页面应用，就不符合项目的目标。

### 1.2. 学习材料

在开始之前，请至少观看以下讲座（这些内容能帮助我快速入门）：
* [CSS 框架](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/css-frameworks)

完成项目时，请观看以下讲座：
* [本地存储](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/javascript-browser-localstorage)
* [事件与回调函数](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/javascript-async-callbacks)
* [Promise](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/javascript-async-promises)
* [AJAX 简介](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/ajax-intro)
* [Fetch](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/ajax-fetch)
* [UI 基础](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/ui-fundamentals)
* [感知性](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/accessibility-perceivability)
* [可操作性](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/accessibility-operability)
* [可理解性](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/accessibility-understandability)
* [健壮性](https://cgi.cse.unsw.edu.au/~cs6080/24T1/content/lectures/accessibility-robustness)

**备注**：你可能需要使用 UNSW 学生账户登录并参加 Web 开发课程才能访问这些材料。不过，你也可以在 YouTube 或 Bilibili 等平台找到相关的学习资源，以补充我的学习内容。

## 2. 项目任务（前端）

我的任务是为 UNSW 版的流行论坛 [EdStem](https://edstem.com/) 构建前端。我已经熟悉这个应用了——它是我们这门课程使用的论坛！

UNSW 版的论坛叫做 "Qanda"。它由一个基于 NodeJS（express）构建的服务器提供支持（详见 3.2 节）。

我已经写出了清晰简洁的功能需求和行为预期。

这些需求描述了一系列 **界面**。界面可以是弹窗/模态框，或者整个页面。"界面" 这一术语为我展示它们提供了灵活性。一个界面基本上表示了我的 Web 应用程序的某个特定状态。

## 2.1. 阶段 1 - 注册与登录

阶段 1 关注的是构建基础的用户界面，用于注册和登录。

### 2.1.1. 登录

* 当用户未登录时，网站应显示登录表单，其中包括：
  * 一个邮箱输入框（文本框）
  * 一个密码输入框（密码框）
  * 一个提交按钮，用于执行登录操作
* 当按下提交按钮时，表单数据将被发送至 `POST /auth/login` 来验证凭证。如果登录过程中出现错误，屏幕上应显示一个适当的错误信息。

### 2.1.2. 注册

* 当用户未登录时，登录表单中应提供一个链接/按钮，打开注册表单。注册表单包含：
  * 一个邮箱输入框（文本框）
  * 一个用户名输入框（文本框）
  * 一个密码输入框（密码框）
  * 一个确认密码输入框（密码框）——这个输入框不会发送给后端，但如果密码不匹配，在提交时应显示错误。
  * 一个提交按钮，用于注册
* 当按下提交按钮时，如果两个密码不匹配，应显示错误弹窗。如果匹配，则将表单数据发送至 `POST /auth/register` 以验证凭证。如果注册过程有错误，应显示适当的错误信息。

### 2.1.3. 错误弹窗

* 每当前端或后端出现错误时，应显示一个错误弹窗，里面有错误信息。这个信息可以来自后端的错误响应，也可以在前端生成。
* 弹窗可以通过点击 "x" 或 "close" 按钮关闭。

### 2.1.4. 仪表盘

* 用户成功注册或登录后，应进入仪表盘页面。
* 初始时，仪表盘将是一个空白页面，仅包含一个始终可见的“注销”按钮。
* 当点击“注销”按钮时，网站的状态中的令牌（例如本地存储）将被移除，用户将被重定向回登录页面。

### 2.2. 阶段 2 - 创建话题

阶段 2 主要集中在如何创建话题并查看该话题（以及其他话题）。

#### 2.2.1. 创建话题

> **什么是“折叠”部分？**  
> 页面上方的部分指的是在不需要滚动的情况下看到的内容。任何需要滚动才能看到的内容都属于“折叠”部分。浏览器窗口的底部是“折叠”位置，而内容继续向下延伸 ([来源](https://www.optimizely.com/optimization-glossary/above-the-fold))。

* 在每个页面的页面上方，应有一个“创建”按钮，点击后跳转到一个新页面。
  * 这个新页面应占据整个页面，排除任何头部或底部内容。
  * 页面上应有标题、内容的输入框，并有一个选项来标记话题是否为私密。
  * 页面上还应有一个提交按钮。
  * 新话题页面应有一个唯一的 URL。
* 提交按钮将通过 `POST /thread` 创建新话题。一旦请求成功，用户将被重定向到一个新页面，展示刚创建的话题（2.2.3）。

#### 2.2.2. 获取话题列表

* 当用户在仪表盘页面时，左侧应显示话题列表（通过 `GET /threads` 获取）。
  * 这个列表的宽度应不超过 `400px`。
* 列表中的每个话题框的高度不得超过 `100px`。
  * 每个框内应显示话题标题、发布日期、作者和点赞数。

#### 2.2.3. 单个话题页面

* 当点击左侧边栏中的某个话题，或创建新话题后，用户将进入一个“单个话题页面”，该页面有一个唯一的 URL（需指定）。
  * 这个 URL 应根据话题 ID 进行参数化。
* 单个话题页面应包含左侧的话题列表（2.2.2），而页面主体内容应包含：
  * 标题
  * 话题内容
  * 点赞数
* 该页面以后将包含编辑、删除、点赞、关注、评论等功能，但在 `2.2.3` 中可以暂时跳过这些功能。

### 2.3. 阶段 3 - 话题互动

阶段 3 主要关注如何与已创建的话题进行互动。

#### 2.3.1. 编辑话题

* 在单个话题页面上，用户应看到一个“编辑”按钮，点击后跳转到一个新页面，页面 URL 根据话题 ID 进行参数化。
* 在此页面上，应有标题、内容的输入框，以及是否将话题设置为私密的选项。这些输入框应预填充当前话题的内容。
* 页面还应有一个保存按钮。
* 编辑话题页面应有一个唯一的 URL。
* 当点击保存按钮时，调用 `PUT /thread` 更新话题内容，当请求返回时，用户应跳转回单个话题页面。

#### 2.3.2. 删除话题

* 在单个话题页面上，用户应看到一个“删除”按钮，点击后将调用 `DELETE /thread` 删除该话题。
* 只有当用户是管理员或该话题的所有者时，删除按钮才会显示。
* 删除请求返回后，页面应重定向到话题列表中最新的单个话题页面。

#### 2.3.3. 点赞话题

* 在单个话题页面上，用户应看到一个“点赞”按钮，点击后通过 `PUT /thread/like` 对话题进行点赞或取消点赞。
* 如果该话题当前已经被该用户点赞，按钮应显示取消点赞的样式；如果该话题尚未被点赞，按钮应显示点赞的样式。
* 任何点赞或取消点赞的操作应立即在 UI 中反映出来。

#### 2.3.4. 关注话题

* 在单个话题页面上，用户应看到一个“关注”按钮，点击后通过 `PUT /thread/watch` 对话题进行关注或取消关注。
* 如果该话题当前已经被该用户关注，按钮应显示取消关注的样式；如果该话题尚未被关注，按钮应显示关注的样式。
* 任何关注或取消关注的操作应立即在 UI 中反映出来。

### 2.4. 阶段 4 - 评论

阶段 4 主要集中在评论的显示、创建、编辑和点赞功能。

#### 2.4.1. 显示评论

* 在单个话题页面加载时，应通过 `GET /comments` 加载所有与该话题相关的评论。
* 评论应以列表形式显示，每条评论包含以下内容：
  * 评论文本
  * 评论者的头像
  * 评论发布的时间，格式为：
    * 如果评论在一分钟内发布，应显示“刚刚”。
    * 如果评论发布超过一分钟，应显示“[时间] [单位]前”，例如“1分钟前”或“7小时前”。时间单位按以下顺序推进：1-59分钟，1-23小时，1-6天，1-N周（N为任何数字）。
  * 评论的点赞数。
* 有些评论可能是对其他评论的回复，这些评论应嵌套在父评论下，并通过视觉缩进表示层级关系。
* 评论应按逆时间顺序排序（最新的评论排在最前面）。嵌套的评论应在其各自的嵌套区域内排序。

#### 2.4.2. 创建评论

* 如果该话题下没有评论，应在话题信息下方显示一个输入框/文本框。
  * 在此输入框下方应有一个“评论”按钮。
  * 当点击“评论”按钮时，输入框中的文本应通过 `POST /comment` 创建为该话题的新评论。
* 如果该话题下已有评论，则不应显示输入框/文本框，而应在每条评论的评论信息区域内显示一个“回复”按钮。
  * 当点击“回复”按钮时，应弹出一个模态框，包含输入框/文本框和一个“评论”按钮。
  * 当点击“评论”按钮时，输入框中的文本应通过 `POST /comment` 创建为新评论，并关闭模态框。

#### 2.4.3. 编辑评论

* 每条评论应在评论信息区域内显示一个“编辑”按钮。
* 当点击“编辑”按钮时，应弹出一个模态框，包含输入框/文本框和一个“评论”按钮。
* 输入框/文本框应包含当前的评论内容。
* 当点击“评论”按钮时，应通过 `PUT /comment` 更新评论内容，并关闭模态框。

#### 2.4.4. 点赞评论

* 每条评论应在评论信息区域内显示一个“点赞”按钮。
* 如果该评论已经被点赞，按钮应显示“取消点赞”。
* 当点击“点赞”按钮时，应通过 `PUT /comment/like` 对评论进行点赞，点赞数应相应更新。
* 当点击“取消点赞”按钮时，应通过 `PUT /comment/like` 对评论取消点赞，点赞数应相应减少。

### 2.5. 阶段 5 - 用户管理

阶段 5 主要集中在用户个人资料和管理员管理权限。

#### 2.5.1. 查看个人资料

* 允许用户点击话题、点赞或评论中的用户名，跳转到该用户的个人资料页面。
* 个人资料页面应包含后台提供的该用户的所有信息（不包括用户 ID）。
* 个人资料页面还应显示该用户创建的所有话题，话题列表应包含标题、内容、点赞数和评论数。

#### 2.5.2. 查看自己的个人资料

* 用户可以像查看其他用户个人资料一样查看自己的个人资料。
* 在大多数页面上，尤其是在信息流页面，应有一个链接，点击后可进入用户个人资料页面。

#### 2.5.3. 更新个人资料

* 用户可以通过 `PUT /user` 更新自己的个人资料，允许更新以下内容：
  * 邮箱地址
  * 密码
  * 姓名
  * 头像（必须从本地系统上传文件）

#### 2.5.4. 将用户升级为管理员

* 如果正在查看其他用户资料的用户是管理员，则该用户应能看到一个下拉菜单，菜单中包含“普通用户”和“管理员”选项。
* 页面上显示的默认选项应反映该用户当前的管理员状态。
* 下拉菜单下方应有一个“更新”按钮，点击后，将用户权限更新为所选择的权限级别。

### 2.6. 阶段 6 - 挑战性组件（`高级`）

#### 2.6.1. 无限滚动

* 用户可以通过无限滚动浏览话题列表，而不需要使用分页功能。为了正确实现无限滚动，你需要在用户滚动时逐步加载新的话题。

#### 2.6.2. 实时更新

* 如果用户点赞或评论了某个话题，该话题的点赞数和评论数应实时更新，无需刷新页面。这应通过某种轮询机制实现。

> **轮询的注意事项：**  
> 轮询对于浏览器来说效率较低，但它能简化服务器端的技术需求，因此常被使用。

#### 2.6.3. 推送通知

* 用户可以在他们关注的用户发布新话题时收到推送通知。要知道某个用户是否发布了新话题，你需要“轮询”服务器（即间隔性请求，可能是每秒一次，检查状态）。你可以通过浏览器内置的通知 API 或自定义的通知弹窗来实现这个功能。  
> **注：** 推送通知仅要求在网页内有效。

> **关于推送通知的研究：**  
> 这部分我可以自行在线研究实现方法，网上有很多资源可以参考。

### 2.7. 阶段 7 - 极具挑战性组件（`高级 *= 2`）

#### 2.7.1. 离线访问静态内容

* 用户即使在没有互联网连接时，也可以访问他们最近浏览的内容。
* 当网络中断时，将最近加载的内容缓存到本地存储。
* 如果用户在离线模式下尝试与网站互动（例如评论或点赞），他们应收到错误提示。

> **关于离线访问的研究：**  
> 这部分我可以自行在线研究实现方法，网上有很多资源可以参考。

#### 2.7.2. 基于 URL 的片段路由

* 用户可以使用 URL 片段访问不同的页面：
```
/#profile=1
/#feed
/#profile=4
```

> 这部分我可以自行在线研究实现方法，网上有很多资源可以参考。

## 3. 开始使用

### 3.1. 前端

初始的模块代码已经提供，帮助你快速开始：
* `frontend/index.html`
* `frontend/styles/global.css`
* `frontend/src/helpers.js`
* `frontend/src/main.js`

可以根据需要修改或删除这些模板文件，它们主要作为参考和帮助使用。

为了在本地使用 Web 服务器并提供前端静态文件服务，你可能需要启动一个额外的 Web 服务器。

要全局安装 `http-server`，运行以下命令：

`$ npm install --global http-server`

然后，在项目根目录中启动服务器：

`$ npx http-server frontend -c 1 -p [端口号]`

其中 `[端口号]` 是你想使用的端口（例如 `8080`），可以使用任意端口号。

启动后，可以通过访问 `http://localhost:8000`（或者提供的 URL/端口）来访问 `index.html`，这将避免 CORS 问题。

### 3.2. 后端

后端提供了 API 接口来为前端提供数据支持。

启动后端服务器：

`$ npm start`

可以通过浏览器访问 `http://localhost:5005` 来查看后端 API 文档，该文档列出了所有可用的 HTTP 路由。

后端提供了一个基础的数据库，包含两个用户和一个公共频道的消息内容。你可以在 `backend/database.json` 文件中查看数据内容。

后端数据是持久化的，即使停止 Express 服务器，数据也会保持。如果你需要将数据库重置为原始状态，可以运行：

`$ npm run reset`

要备份数据库，只需复制 `database.json` 文件。如果你想清空数据库，可以运行：

`$ npm run clear`

后端端口在 `frontend/src/config.js` 文件中定义，这有助于前端与后端进行通信。

如果手动更新了 `database.json` 文件，记得重启后端服务器。

### 3.3. 关于项目开始的第一步

推荐的第一步：
 1. 阅读整个项目规范，特别是第2部分，以了解接下来的任务。
 2. 打开 `index.html` 文件，确认能看到一个简单的 "Hello World" 消息，以确保访问的是正确的页面。
 3. 规划用户界面，考虑所有关键屏幕以及它们所依赖的数据。
 4. 启动后端服务器，检查是否能正常工作，可以通过调用 `/feed` API 端点来测试（返回结果应为空列表）。
 5. 开始编码！

### 3.4. 发起一个 Fetch 请求

这里是一个发起 POST 请求的入门代码示例（用于非认证的路由）。注意，做这件事有很多种方式，可能有些方法更简洁，但这个例子可以帮助入门。

```javascript
const apiCall = (path, body) => {
    fetch('http://localhost:5005/' + path, {
        method: 'POST',
        headers: {
            'Content-type': 'application/json',
        },
        body: JSON.stringify(body)
    })
    .then((response) => response.json())
    .then((data) => {
        if (data.error) {
            alert(data.error);
        } else {
            resolve(data);
        }
    });
};


以下是发起 GET 请求的代码示例（用于认证的路由）。请注意，也有很多其他方法（有些可能比这个更简洁），这只是一个入门的示例。

```Javascript
const apiCall = (path, token, queryString) => {
    fetch('http://localhost:5005/' + path + '?' + queryString, {
	  method: 'GET',
	  headers: {
        'Content-type': 'application/json',
		'Authorization': `Bearer ${token}`
      },
	})
      .then((response) => response.json())
      .then((data) => {
        if (data.error) {
          alert(data.error);
        } else {
          resolve(data);
        }
      });
};
```

## 4. 项目注意事项

### 4.1. JavaScript

 * 本项目必须使用符合 ES6 规范的原生 JavaScript 实现。不能使用 ReactJS、JQuery 或其他抽象框架。例如，不能使用像 [Angular](https://angular.io/) 或 [React](https://reactjs.org/) 这样的流行 JavaScript 框架。
 * **不得**直接使用外部 JavaScript。除非项目获得批准，否则不要使用 NPM 安装开发类库。

### 4.2. CSS 和其他库

 * 可以在项目中引入外部 CSS 库（使用 `<link />` 标签）。必须注明这些资源的出处（即在源代码注释中提供 URL 或作者信息）。例如，可以使用流行的 [Bootstrap](https://getbootstrap.com/) CSS 框架。部分 Bootstrap 功能依赖于伴随的 JavaScript，可以包含这些 JavaScript。Bootstrap 附带的 JavaScript 需要使用流行的通用 JavaScript 库 [jQuery](https://jquery.com/)。可以包含 jQuery 来使 Bootstrap 正常工作。但不能在项目中编写的代码里使用 **jQuery**。

### 4.3. 浏览器兼容性

确保项目已经在以下浏览器之一进行过测试：
 * 本地：Google Chrome（各种操作系统）

### 4.4. 对于这个项目的其他要求

 * 项目规范故意保持模糊，以便可以根据自己的需求构建前端组件。组件的大小、位置、颜色和布局通常由自身决定。提供了一些基本标准，但主要关注的是元素和行为。
 * 该 Web 应用程序必须是单页应用（SPA）。这意味着，页面应该只加载一次初始内容，所有后续的动态页面变化都应该通过 JavaScript 操作 DOM 来实现，而不是通过页面刷新。如果没有构建单页应用（例如，使用多个 HTML 页面进行跳转），那么项目将不太符合要求。

### 4.5. 静态 HTML、innerHTML 和 DOM 操作

在本项目中，你需要：
 * 向提供的模板网站中添加静态 HTML/CSS（即，你可以添加原始 HTML/CSS，尽管稍后可能会用 JavaScript 对其进行操作）。
 * 使用 JavaScript 构建 HTML 元素，并将 CSS 属性添加到 DOM 中。
 * 使用如 `insertAdjacentHTML` 和 `innerText` 这样的属性/函数。

### 4.6. 不太允许的部分

 * 项目中不得包含超过 1 个 HTML 文件。
 * 不得使用 `async` 和 `await` 语法。你必须使用 JavaScript 的 Promise。
 * 不得使用任何字符串到 DOM 的解析方法（例如 `DOMParser`、`innerHTML` 属性或类似方法）。

### 5. 鸣谢

我想对我在 UNSW 本科阶段所参加的 Web 开发课程表示衷心的感谢。该课程提供的材料和知识对我开发这个项目起到了至关重要的作用。我通过这门课程获得的基础技能和最佳实践在整个开发过程中为我提供了指导，我非常感激课程内容、讲座和资源的支持。
